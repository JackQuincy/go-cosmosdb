// Code generated by github.com/jim-minter/go-cosmosdb, DO NOT EDIT.

package cosmosdb

import (
	"net/http"

	pkg "github.com/jim-minter/go-cosmosdb/example/types"
)

type personClient struct {
	*databaseClient
	path          string
	isPartitioned bool
}

// PersonClient is a person client
type PersonClient interface {
	Create(string, *pkg.Person) (*pkg.Person, error)
	List() PersonIterator
	Get(string, string) (*pkg.Person, error)
	Replace(string, *pkg.Person) (*pkg.Person, error)
	Delete(string, *pkg.Person) error
	Query(*Query) PersonIterator
}

type personListIterator struct {
	*personClient
	continuation string
	done         bool
}

type personQueryIterator struct {
	*personClient
	query        *Query
	continuation string
	done         bool
}

// PersonIterator is a person iterator
type PersonIterator interface {
	Next() (*pkg.People, error)
}

// NewPersonClient returns a new person client
func NewPersonClient(collc CollectionClient, collid string, isPartitioned bool) PersonClient {
	return &personClient{
		databaseClient: collc.(*collectionClient).databaseClient,
		path:           collc.(*collectionClient).path + "/colls/" + collid,
		isPartitioned:  isPartitioned,
	}
}

func (c *personClient) Create(partitionkey string, newperson *pkg.Person) (person *pkg.Person, err error) {
	headers := http.Header{}
	if partitionkey != "" {
		headers.Set("X-Ms-Documentdb-Partitionkey", `["`+partitionkey+`"]`)
	}
	err = c.do(http.MethodPost, c.path+"/docs", "docs", c.path, http.StatusCreated, &newperson, &person, headers)
	return
}

func (c *personClient) List() PersonIterator {
	return &personListIterator{personClient: c}
}

func (c *personClient) Get(partitionkey, personid string) (person *pkg.Person, err error) {
	headers := http.Header{}
	if partitionkey != "" {
		headers.Set("X-Ms-Documentdb-Partitionkey", `["`+partitionkey+`"]`)
	}
	err = c.do(http.MethodGet, c.path+"/docs/"+personid, "docs", c.path+"/docs/"+personid, http.StatusOK, nil, &person, headers)
	return
}

func (c *personClient) Replace(partitionkey string, newperson *pkg.Person) (person *pkg.Person, err error) {
	if newperson.ETag == "" {
		return nil, ErrETagRequired
	}
	headers := http.Header{}
	headers.Set("If-Match", newperson.ETag)
	if partitionkey != "" {
		headers.Set("X-Ms-Documentdb-Partitionkey", `["`+partitionkey+`"]`)
	}
	err = c.do(http.MethodPut, c.path+"/docs/"+newperson.ID, "docs", c.path+"/docs/"+newperson.ID, http.StatusOK, &newperson, &person, headers)
	return
}

func (c *personClient) Delete(partitionkey string, person *pkg.Person) error {
	if person.ETag == "" {
		return ErrETagRequired
	}
	headers := http.Header{}
	headers.Set("If-Match", person.ETag)
	if partitionkey != "" {
		headers.Set("X-Ms-Documentdb-Partitionkey", `["`+partitionkey+`"]`)
	}
	return c.do(http.MethodDelete, c.path+"/docs/"+person.ID, "docs", c.path+"/docs/"+person.ID, http.StatusNoContent, nil, nil, headers)
}

func (c *personClient) Query(query *Query) PersonIterator {
	return &personQueryIterator{personClient: c, query: query}
}

func (i *personListIterator) Next() (people *pkg.People, err error) {
	if i.done {
		return
	}

	headers := http.Header{}
	if i.continuation != "" {
		headers.Set("X-Ms-Continuation", i.continuation)
	}

	err = i.do(http.MethodGet, i.path+"/docs", "docs", i.path, http.StatusOK, nil, &people, headers)
	if err != nil {
		return
	}

	i.continuation = headers.Get("X-Ms-Continuation")
	i.done = i.continuation == ""

	return
}

func (i *personQueryIterator) Next() (people *pkg.People, err error) {
	if i.done {
		return
	}

	headers := http.Header{}
	headers.Set("X-Ms-Documentdb-Isquery", "True")
	headers.Set("Content-Type", "application/query+json")
	if i.isPartitioned {
		headers.Set("X-Ms-Documentdb-Query-Enablecrosspartition", "True")
	}
	if i.continuation != "" {
		headers.Set("X-Ms-Continuation", i.continuation)
	}

	err = i.do(http.MethodPost, i.path+"/docs", "docs", i.path, http.StatusOK, &i.query, &people, headers)
	if err != nil {
		return
	}

	i.continuation = headers.Get("X-Ms-Continuation")
	i.done = i.continuation == ""

	return
}
